# cpp_learn

## Nowdays

[C++ Primer 5th](#c-primer-5th)

## Future

Effective C++  
More Effective C++  
Inside the C++ Object Model  
The Annotated STL Sources  
C++ concurrency in action  
C++ Templates

---

## C++ Primer 5th

[我的代码](./cpp_primer/source) 和 [参考答案](https://github.com/Mooophy/Cpp-Primer)

### ch1

1.复习一下CSAPP学的不同类型运算的转换，有符号和无符号运算，默认先转为无符号，先保证同有无符号；然后如果大小不同，那么符号扩展到相同类型，要明白只有相同类型才能运算。

### ch2

1.extern是只声明不定义(此时不能跟着值,不然失效)，从而让别的文件的变量能为程序所知，提示编译器遇到此变量和函数时在其他模块中寻找其定义；而不带extern的是声明并定义(这里带上extern也是定义，失去了作用，不过可以当成一个注释的作用)，会获得一个具名的可操作的对象实体。

2.引用本身和硬链接类似，没有所谓的实体(硬链接没有inode)，只是实体的一个别名而已

3.看复合类型从右往左最贴近标识符的说明了类型

  ```c++v
  int *& val; => int *(&val); // 比如这个复制的类型，其实是对int *的引用
  ```

4.多个文件同名的全局变量定义，是分别定义使用的，不会干扰，这是默认情况，多文件重名的分别定义不共享；如果需要共享那么只能定义一次(不然会不知道声明引用的是哪一个)，然后extern声明。
如果想要共享，那么最好全部加上extern，定义的那个可加可不加(最好加上来表明这个定义要被其他文件使用)

5.引用绑定之后就不再改变绑定到其他对象了，所以它的const只是代表绑定实体本身（如果是指针的引用，那么指针本身变量是const，即指针不能改变指向，而不是指向的变量是const）是const的。

6.类型转换(截断或者提升)是一种运算，产生一个临时值(是右值)，可以看成结果是一个常量，和原来的左值变量没有关系，一个是原来的变量，一个是新的临时常量。

7.const引用绑定了一个变量，注意如果这里绑定的是一个临时值还是一个真的变量，如果发生类型转换运算，那么运算结果是一个临时值，这时候绑定的是这个临时右值(和字面值一样)，与那个变量无关的；没有运算，没有类型转换运算，是个左值，那么虽然不可以通过const引用改变，但可以通过其他途径改值，const引用绑定的实体能体现出来的。

8.using TYPE = type;

9.auto

10.decltype

### ch3
