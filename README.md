# cpp_learn
Iyaiya~~

## Nowdays:

[C++ Primer 5th](#c-primer-5th)<br>
Effective C++

## Future:

More Effective C++<br>
Inside the C++ Object Model<br>
The Annotated STL Sources<br>
C++ concurrency in action<br>
C++ Templates

---

## C++ Primer 5th
[本书源代码](./cpp_primer/source) 和 [参考答案](https://github.com/Mooophy/Cpp-Primer)(膜大佬)

### ch1
1.有符号和无符号运算，默认先转为无符号

### ch2
1.extern是只声明不定义(此时不能跟着值,不然失效)，从而让别的文件的变量能为程序所知，提示编译器遇到此变量和函数时在其他模块中寻找其定义；而不带extern的是声明并定义(这里带上extern也是定义，失去了作用，不过可以当成一个注释的作用)，会获得一个具名的可操作的对象实体。

2.引用本身和硬链接类似，没有所谓的实体(硬链接没有inode)，只是实体的一个别名而已 

3.看复合类型从右往左最贴近标识符的说明了类型，int *& val; => int *(&val); 是对int *的引用

4.多个文件同名的全局变量定义，是分别定义使用的，不会干扰，这是默认情况，多文件重名的分别定义不共享；如果需要共享那么只能定义一次(不然会不知道声明引用的是哪一个)，然后extern声明。
如果想要共享，那么最好全部加上extern，定义的那个可加可不加(最好加上来表明这个定义要被其他文件使用)

5.引用绑定之后就不再改变绑定到其他对象了，所以它的const只是代表绑定实体本身（如果是指针的引用，那么指针本身变量是const，即指针不能改变指向，而不是指向的变量是const）是const的。

6.类型转换(截断或者提升)是一种运算，产生一个临时值(是右值)，可以看成结果是一个常量，和原来的左值变量没有关系，一个是原来的变量，一个是新的临时常量。

7.const引用绑定了一个变量，注意如果这里绑定的是一个临时值还是一个真的变量，如果发生类型转换运算，那么运算结果是一个临时值，这时候绑定的是这个临时右值(和字面值一样)，与那个变量无关的；没有运算，没有类型转换运算，是个左值，那么虽然不可以通过const引用改变，但可以通过其他途径改值，const引用绑定的实体能体现出来的。

8.using TYPE = type;

9.auto

10.decltype

### ch3
